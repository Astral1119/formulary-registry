{"name":"anduin","version":"0.2.0","description":"A library implementing Clojure-like object oriented programming features","owners":["Astral1119"],"dependencies":["error>=0.2.0","container>=0.2.0"],"latest":true,"hasDocs":false,"keywords":"functional, oop, object, clojure, record, protocol","homepage":"https://sheets.wiki","license":"MIT","searchIndex":"anduin A library implementing Clojure-like object oriented programming features ['functional', 'oop', 'object', 'clojure', 'record', 'protocol'] PROTOCOL Creates a Clojure-like PROTOCOL object which can be used with RECORDs. RECORD Creates a Clojure-like RECORD object that supports PROTOCOLs.","functions":{"PROTOCOL":{"definition":"=lambda(_payload,\n  choose(xmatch(_payload, {\"@help\"; \"@kind\"; \"@items\"; \"@repr\"}, ),\n    {\n      \"help for PROTOCOL\", \"\";\n      \"For in-depth documentation, see container documentation at https://sheets.wiki/project/anduin/\", \"\";\n      \"PROTOCOL defines a set of traits that can be implemented by RECORDs.\", \"\";\n      \"@help\", \"Display help for PROTOCOL.\";\n      \"@kind\", \"Gives the kind of the object (\"\"protocol\"\").\";\n      \"@items\", \"Returns a sorted array of the trait names in the PROTOCOL.\";\n      \"@repr\", \"Returns a string representation of the PROTOCOL.\"\n    },\n    \"protocol\",\n    sort(\"@\"&tocol(traits)),\n    \"#protocol<\" & textjoin(\", \", true, sort(\"@\"&tocol(traits))) & \">\"\n  )\n)\n","description":"Creates a Clojure-like PROTOCOL object which can be used with RECORDs.","arguments":{"traits":{"description":"The traits that a RECORD that supports this PROTOCOL must define, as a vector.","example":"{\"add_pet\", \"list_pets\"}"}}},"RECORD":{"definition":"=let(\n  _record, lambda(self, data, traits,\n    lambda(_payload,\n      if(\n        type(_payload) = 64,\n        map(_payload, lambda(key, data(\"@get\")(key))),\n\n        if(\n          istext(_payload),\n          let(\n            all_traits, {\"@help\"; \"@update\"; \"@repr\"; \"@items\"; \"@traits\"; traits(\"@keys\")},\n            idx, xmatch(_payload, all_traits, ),\n            if(\n              iserror(idx),\n              data(\"@get\")(_payload),\n              if(\n                idx < 6,\n                choose(\n                  idx,\n                  {\n                    \"help for RECORD\", \"\";\n                    \"For in-depth documentation, see container documentation at https://sheets.wiki/project/anduin/\", \"\";\n                    \"RECORDs are flexible data structures that support protocols. Access fields by key (text or number) or use built-in traits.\", \"\";\n                    \"@help\", \"Display help for RECORD.\";\n                    \"@update\", \"Update a field value (returns a new record). Follow with (key, value)\";\n                    \"@repr\", \"Returns a string representation of the RECORD.\";\n                    \"@items\", \"Returns the underlying DICT containing the data.\";\n                    \"@traits\", \"Returns the DICT containing the implemented traits/protocols.\";\n                    \"@kind\", \"Gives the kind of the RECORD.\"\n                  },\n                  lambda(key, value, self(self, data(\"@update\")(key, value), traits)),\n                  if(\n                    isnumber(xmatch(\"@repr\", traits(\"@keys\"), )),\n                    traits(\"@get\")(\"@repr\")(self(self, data, traits)),\n                    \"#record:\" & traits(\"@get\")(\"@kind\")(self(self, data, traits)) & \"<\" & textjoin(\", \", true, filter(traits(\"@keys\"), left(traits(\"@keys\")) = \"@\")) & \">\" & mid(REPR(data), 6, 9^9)\n                  ),\n                  data,\n                  traits\n                ),\n                traits(\"@get\")(_payload)(self(self, data, traits))\n              )\n            )\n          ),\n          if(\n            isnumber(_payload),\n            data(\"@get\")(_payload),\n            THROW(\"RECORD received an unexpected payload.\")\n          )\n        )\n      )\n    )\n  ),\n\n  _instantiate, lambda(_instantiate, vector, traits, lambda(_payload,\n    if(\n      iferror(index(_payload(\"@kind\") = \"protocol\", 1, 1)),\n      let(\n        protocol_traits, _payload(\"@items\"),\n\n        trait_constructor, lambda(dict, _instantiate(_instantiate, vector, dict)),\n\n        builder, reduce(\n          trait_constructor,\n          sort(protocol_traits, sequence(rows(protocol_traits)), ),\n          lambda(\n            prev,\n            cur,\n            lambda(\n              dict,\n              let(\n                next, lambda(\n                  this,\n                  lambda(\n                    __payload,\n                    if(\n                      isna(__payload),\n                      prev(dict(\"@update\")(cur, __payload)),\n                      this(this)\n                    )\n                  )\n                ),\n                next(next)\n              )\n            )\n          )\n        ),\n\n        builder(traits)\n      ),\n      let(\n        base_constructor, lambda(list,\n          _record(\n            _record,\n            DICT(\"@from_list\")(tocol(vector), list),\n            traits\n          )\n        ),\n        vecrows, rows(tocol(vector)),\n        if(\n          vecrows < 2,\n          base_constructor,\n          reduce(\n            base_constructor,\n            sequence(vecrows - 1),\n            lambda(\n              prev,\n              cur,\n              lambda(\n                list,\n                lambda(value,\n                  prev(list(\"@push\")(value))\n                )\n              )\n            )\n          )\n        )(LIST(\"@push\")(_payload))\n      )\n    )\n  )),\n\n  lambda(vector, _instantiate(\n    _instantiate,\n    vector,\n    DICT\n      (\"@update\")(\"@kind\", lambda(self, kind))\n  ))\n)\n","description":"Creates a Clojure-like RECORD object that supports PROTOCOLs.","arguments":{"kind":{"description":"The kind of object you are creating.","example":"ANIMAL"}}}}}
