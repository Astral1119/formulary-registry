{"name":"container","version":"0.1.0","description":"Purely functional containers","owners":["Astral1119"],"dependencies":["error","hash"],"latest":false,"hasDocs":false,"keywords":"container, dict, dictionary, map","homepage":"https://sheets.wiki","license":"MIT","searchIndex":"container Purely functional containers ['container','dict','dictionary','map'] DICT LIST","functions":{"DICT":{"definition":"=let(\n  _dict, lambda(self, keys, list,\n    let(\n      update, lambda(key, value,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            self(\n              self,\n              {keys; key},\n              list(\"@push\")(value)\n            ),\n            self(\n              self,\n              keys,\n              list(\"@update\")(idx, value)\n            )\n          )\n        )\n      ),\n\n      get, lambda(key,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            THROW(\"Key \"&key&\" does not exist in DICT.\"),\n            list(idx)\n          )\n        )\n      ),\n\n      remove, lambda(key,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            THROW(\"Key \"&key&\" does not exist in DICT.\"),\n            self(\n              self,\n              filter(keys, keys <> key),\n              list(\"@remove\")(idx)\n            )\n          )\n        )\n      ),\n\n      from_list, lambda(new_keys, new_list, self(self, new_keys, new_list)),\n\n      lambda(_payload,\n        let(\n          traits, {\"@kind\"; \"@update\"; \"@get\"; \"@remove\"; \"@keys\"; \"@items\"; \"@from_list\"; \"@hash\"},\n\n          idx, iferror(xmatch(index(_payload, 1, 1), traits)),\n\n          if(\n            idx,\n\n            choose(\n              idx,\n              \"dict\",\n              update,\n              get,\n              remove,\n              keys,\n              list,\n              from_list,\n              HASH({keys; HASH(list)})\n            ),\n\n            if(\n              type(_payload) = 64,\n              if(\n                rows(tocol(_payload)) <> 2,\n                THROW(\"Cannot insert a vector of size \"&rows(tocol(_payload))&\"into DICT. Must be size 2.\"),\n                update(index(_payload, 1), index(_payload, 2))\n              ),\n              if(\n                or(istext(_payload), isnumber(_payload)),\n                get(_payload),\n                THROW(\"DICT received an unexpected payload.\")\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n\n  _dict(\n    _dict,\n    tocol(,1),\n    LIST\n  )(payload)\n)\n","description":"","arguments":{"payload":{"description":"No description provided.","example":"No example provided."}}},"LIST":{"definition":"=let(\n  _list, lambda(self, size, object,\n    lambda(_payload,\n      let(\n        traits, {\"@traits\"; \"@kind\"; \"@push\"; \"@insert\"; \"@get\"; \"@size\"; \"@remove\"; \"@update\"; \"@items\"; \"@prepend\"; \"@hash\"; \"@apply\"},\n\n        idx, iferror(xmatch(index(_payload, 1, 1), traits)),\n\n        if(\n          idx,\n\n          choose(\n            idx,\n            traits,\n            \"list\",\n            lambda(value, self(self, size + 1, lambda(opt, choose(opt, value, object)))),\n            let(\n              _insert, lambda(_insert, obj, idx, value,\n                if(\n                  idx,\n                  lambda(opt,\n                    choose(\n                      opt,\n                      obj(1),\n                      _insert(_insert, obj(2), idx - 1, value)\n                    )\n                  ),\n                  lambda(opt,\n                    choose(\n                      opt,\n                      value,\n                      obj\n                    )\n                  )\n                )\n              ),\n\n              lambda(idx, value,\n                if(\n                  idx > size + 1,\n                  THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n                  self(self, size + 1,\n                    if(\n                      idx,\n                      _insert(_insert, object, size - idx + 1, value),\n                      lambda(opt,\n                        choose(\n                          opt,\n                          value,\n                          object\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            ),\n\n            lambda(idx,\n              if(\n                idx > size,\n                THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n                if(\n                  idx = size,\n                  object(1),\n                  reduce(\n                    object,\n                    sequence(size - idx),\n                    lambda(\n                      acc,\n                      cur,\n                      acc(2)\n                    )\n                  )(1)\n                )\n              )\n            ),\n\n            size,\n\n            let(\n              _remove, lambda(_remove, obj, idx,\n                if(\n                  idx,\n                  lambda(opt,\n                    choose(\n                      opt,\n                      obj(1),\n                      _remove(_remove, obj(2), idx - 1)\n                    )\n                  ),\n                  obj(2)\n                )\n              ),\n\n              lambda(idx,\n                if(\n                  idx > size,\n                  THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n                  self(self, size - 1,\n                    if(\n                      idx,\n                      _remove(_remove, object, size - idx),\n                      object(2)\n                    )\n                  )\n                )\n              )\n            ),\n\n            let(\n              _update, lambda(_update, obj, idx, value,\n                if(\n                  idx,\n                  lambda(opt,\n                    choose(\n                      opt,\n                      obj(1),\n                      _update(_update, obj(2), idx - 1, value)\n                    )\n                  ),\n                  lambda(opt,\n                    choose(\n                      opt,\n                      value,\n                      obj(2)\n                    )\n                  )\n                )\n              ),\n\n              lambda(idx, value, if(idx > size, THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"), self(self, size, _update(_update, object, size - idx, value))))\n            ),\n\n            object,\n\n            let(\n              _prepend, lambda(_prepend, obj, idx, to_prepend,\n                if(\n                  idx,\n                  lambda(opt,\n                    choose(\n                      opt,\n                      obj(1),\n                      _prepend(_prepend, obj(2), idx - 1, to_prepend)\n                    )\n                  ),\n                  to_prepend\n                )\n              ),\n\n              lambda(other,\n                if(\n                  ISKIND(other, \"list\"),\n                  self(self, size + other(\"@size\"), _prepend(_prepend, object, size, other(\"@items\"))),\n                  THROW(\"Can only prepend other LISTs.\")\n                )\n              )\n            ),\n\n            HASH(map(sequence(size), lambda(a, get(a)))),\n            \n            let(\n              _apply, lambda(_apply, obj, fn, idx,\n                if(\n                  idx,\n                  lambda(opt,\n                    choose(\n                      opt,\n                      fn(obj(1)),\n                      _apply(_apply, obj(2), fn, idx - 1)\n                    )\n                  ),\n\n                )\n              ),\n\n              lambda(fn,\n                self(self, size, _apply(_apply, object, fn, size))\n              )\n            )\n          ),\n\n          if(\n            and(type(_payload) = 1, isnumber(index(_payload, 1, 1))),\n\n            if(\n              _payload > size,\n              THROW(\"Index \"&_payload&\" is out of bounds for LIST of size \"&size&\".\"),\n              if(\n                _payload = size,\n                object(1),\n                reduce(\n                  object,\n                  sequence(size - _payload),\n                  lambda(\n                    acc,\n                    cur,\n                    acc(2)\n                  )\n                )(1)\n              )\n            ),\n\n            self(self, size + 1, lambda(opt, choose(opt, _payload, object)))\n          )\n        )\n      )\n    )\n  ),\n\n  _list(\n      _list,\n      ,\n      lambda(opt,\n      choose(\n        opt,\n        ,\n\n      )\n    )\n  )(payload)\n)\n","description":"","arguments":{"payload":{"description":"No description provided.","example":"No example provided."}}}}}
