{"name":"container","version":"0.2.0","description":"Purely functional containers","owners":["Astral1119"],"dependencies":["debug","error>=0.2.0"],"latest":true,"hasDocs":false,"keywords":"container, dict, dictionary, map","homepage":"https://sheets.wiki","license":"MIT","searchIndex":"container Purely functional containers ['container','dict','dictionary','map'] DICT LIST A Church-encoded list of terms. Try LIST(\"@help\") for more.","functions":{"DICT":{"definition":"=let(\n  _dict, lambda(self, keys, list,\n    let(\n      update, lambda(key, value,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            self(\n              self,\n              {keys; key},\n              list(\"@push\")(value)\n            ),\n            self(\n              self,\n              keys,\n              list(\"@update\")(idx, value)\n            )\n          )\n        )\n      ),\n\n      get, lambda(key,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            THROW(\"Key \"&key&\" does not exist in DICT.\"),\n            list(idx)\n          )\n        )\n      ),\n\n      remove, lambda(key,\n        let(\n          idx, xmatch(key, keys, ),\n          if(\n            isna(idx),\n            THROW(\"Key \"&key&\" does not exist in DICT.\"),\n            self(\n              self,\n              filter(keys, keys <> key),\n              list(\"@remove\")(idx)\n            )\n          )\n        )\n      ),\n\n      from_list, lambda(new_keys, new_list, self(self, new_keys, new_list)),\n\n      lambda(_payload,\n        let(\n          traits, {\"@help\"; \"@kind\"; \"@update\"; \"@get\"; \"@remove\"; \"@keys\"; \"@items\"; \"@from_list\"; \"@repr\"},\n\n          idx, iferror(xmatch(index(_payload, 1, 1), traits)),\n\n          if(\n            idx,\n\n            choose(\n              idx,\n              {\n                \"help for DICT\", \"\";\n                \"For in-depth documentation, see container documentation at https://sheets.wiki/project/container/\", \"\";\n                \"If the payload is a text or number, DICT will return the value at that key. If the payload is a vector of size 2, it will update the key with the value.\", \"\";\n                \"@help\", \"Display help for DICT.\";\n                \"@kind\", \"Gives the kind of the object (\"\"dict\"\").\";\n                \"@update\", \"Update a key-value pair. Follow with (key, value)\";\n                \"@get\", \"Get a value for a specific key. Follow with (key)\";\n                \"@remove\", \"Remove a key-value pair. Follow with (key)\";\n                \"@keys\", \"Gives the keys of the DICT.\";\n                \"@items\", \"Gives the LIST object containing the values.\";\n                \"@from_list\", \"Create a new DICT from a list of keys and a LIST object. Follow with (keys, list)\";\n                \"@repr\", \"Gives a string representation of the DICT.\"\n              },\n              \"dict\",\n              update,\n              get,\n              remove,\n              keys,\n              list,\n              from_list,\n              if(\n                rows(keys),\n                \"#dict{\" & reduce(\n                  lambda(\n                    i,\n                    choose(\n                      i,\n                      ,\n                      list(\"@items\")\n                    )\n                  ),\n                  sequence(rows(keys), 1, rows(keys), -1),\n                  lambda(\n                    acc,\n                    cur,\n                    lambda(\n                      i,\n                      choose(\n                        i,\n                        textjoin(\"; \", 1, \"\"\"\" & index(keys, cur)&\"\"\", \"&REPR(acc(2)(1)), acc(1)),\n                        acc(2)(2)\n                      )\n                    )\n                  )\n                )(1) & \"}\", \n                \"#dict{}\"\n              )\n            ),\n\n            if(\n              type(_payload) = 64,\n              if(\n                rows(tocol(_payload)) <> 2,\n                THROW(\"Cannot insert a vector of size \"&rows(tocol(_payload))&\"into DICT. Must be size 2.\"),\n                update(index(_payload, 1), index(_payload, 2))\n              ),\n              if(\n                or(istext(_payload), isnumber(_payload)),\n                get(_payload),\n                THROW(\"DICT received an unexpected payload.\")\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n\n  _dict(\n    _dict,\n    tocol(,1),\n    LIST\n  )(payload)\n)\n","description":"","arguments":{"payload":{"description":"No description provided.","example":"No example provided."}}},"LIST":{"definition":"=let(\n  _list, lambda(self, size, object,\n    lambda(_payload,\n      if(\n        condition_one_of_range(index(_payload, 1, 1), \"@help\", \"@kind\", \"@push\", \"@insert\", \"@get\", \"@size\", \"@remove\", \"@update\", \"@items\", \"@prepend\", \"@apply\", \"@repr\"),\n\n        choose(\n          xmatch(_payload, {\"@help\"; \"@kind\"; \"@push\"; \"@insert\"; \"@get\"; \"@size\"; \"@remove\"; \"@update\"; \"@items\"; \"@prepend\"; \"@apply\"; \"@repr\"}),\n          {\n            \"help for LIST\", \"\";\n            \"For in-depth documentation, see container documentation at https://sheets.wiki/project/container/\", \"\";\n            \"If the payload is a number, LIST will return the element at that index. Otherwise, it will push the payload to the end of the LIST.\", \"\";\n            \"@help\", \"Display help for LIST.\";\n            \"@kind\", \"Gives the kind of the object (\"\"list\"\").\";\n            \"@push\", \"Push a value to the end of the LIST. Follow with (value)\";\n            \"@insert\", \"Insert a value at a specific index. Follow with (index, value)\";\n            \"@get\", \"Get a value at a specific index. Follow with (index)\";\n            \"@size\", \"Gives the size of the LIST.\";\n            \"@remove\", \"Remove a value at a specific index. Follow with (index)\";\n            \"@update\", \"Update a value at a specific index. Follow with (index, value)\";\n            \"@items\", \"Gives the items of the LIST. Only use if you need the raw LIST object.\";\n            \"@prepend\", \"Prepend a value to the start of the LIST. Follow with (value)\";\n            \"@apply\", \"Apply a function to each element of the LIST. Follow with (fn)\";\n            \"@repr\", \"Gives a string representation of the LIST.\"\n          },\n          \"list\",\n          lambda(value, self(self, size + 1, lambda(opt, choose(opt, value, object)))),\n          let(\n            _insert, lambda(_insert, obj, idx, value,\n              if(\n                idx,\n                lambda(opt,\n                  choose(\n                    opt,\n                    obj(1),\n                    _insert(_insert, obj(2), idx - 1, value)\n                  )\n                ),\n                lambda(opt,\n                  choose(\n                    opt,\n                    value,\n                    obj\n                  )\n                )\n              )\n            ),\n\n            lambda(idx, value,\n              if(\n                idx > size + 1,\n                THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n                self(self, size + 1,\n                  if(\n                    idx,\n                    _insert(_insert, object, size - idx + 1, value),\n                    lambda(opt,\n                      choose(\n                        opt,\n                        value,\n                        object\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          ),\n\n          lambda(idx,\n            if(\n              idx > size,\n              THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n              if(\n                idx = size,\n                object(1),\n                reduce(\n                  object,\n                  sequence(size - idx),\n                  lambda(\n                    acc,\n                    cur,\n                    acc(2)\n                  )\n                )(1)\n              )\n            )\n          ),\n\n          size,\n\n          let(\n            _remove, lambda(_remove, obj, idx,\n              if(\n                idx,\n                lambda(opt,\n                  choose(\n                    opt,\n                    obj(1),\n                    _remove(_remove, obj(2), idx - 1)\n                  )\n                ),\n                obj(2)\n              )\n            ),\n\n            lambda(idx,\n              if(\n                idx > size,\n                THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"),\n                self(self, size - 1,\n                  if(\n                    idx,\n                    _remove(_remove, object, size - idx),\n                    object(2)\n                  )\n                )\n              )\n            )\n          ),\n\n          let(\n            _update, lambda(_update, obj, idx, value,\n              if(\n                idx,\n                lambda(opt,\n                  choose(\n                    opt,\n                    obj(1),\n                    _update(_update, obj(2), idx - 1, value)\n                  )\n                ),\n                lambda(opt,\n                  choose(\n                    opt,\n                    value,\n                    obj(2)\n                  )\n                )\n              )\n            ),\n\n            lambda(idx, value, if(idx > size, THROW(\"Index \"&idx&\" is out of bounds for LIST of size \"&size&\".\"), self(self, size, _update(_update, object, size - idx, value))))\n          ),\n\n          object,\n\n          let(\n            _prepend, lambda(_prepend, obj, idx, to_prepend,\n              if(\n                idx,\n                lambda(opt,\n                  choose(\n                    opt,\n                    obj(1),\n                    _prepend(_prepend, obj(2), idx - 1, to_prepend)\n                  )\n                ),\n                to_prepend\n              )\n            ),\n\n            lambda(other,\n              if(\n                ISKIND(other, \"list\"),\n                self(self, size + other(\"@size\"), _prepend(_prepend, object, size, other(\"@items\"))),\n                THROW(\"Can only prepend other LISTs.\")\n              )\n            )\n          ),\n\n          let(\n            _apply, lambda(_apply, obj, fn, idx,\n              if(\n                idx,\n                lambda(opt,\n                  choose(\n                    opt,\n                    fn(obj(1)),\n                    _apply(_apply, obj(2), fn, idx - 1)\n                  )\n                ),\n\n              )\n            ),\n\n            lambda(fn,\n              self(self, size, _apply(_apply, object, fn, size))\n            )\n          ),\n\n          \"#list{\" & reduce(\n            lambda(\n              i,\n              choose(\n                i,\n                ,\n                object\n              )\n            ),\n            sequence(size),\n            lambda(\n              acc,\n              cur,\n              lambda(\n                i,\n                choose(\n                  i,\n                  textjoin(\"; \", 1, REPR(acc(2)(1)), acc(1)),\n                  acc(2)(2)\n                )\n              )\n            )\n          )(1) & \"}\", \n        ),\n\n        if(\n          and(type(_payload) = 1, isnumber(index(_payload, 1, 1))),\n\n          if(\n            _payload > size,\n            THROW(\"Index \"&_payload&\" is out of bounds for LIST of size \"&size&\".\"),\n            if(\n              _payload = size,\n              object(1),\n              reduce(\n                object,\n                sequence(size - _payload),\n                lambda(\n                  acc,\n                  cur,\n                  acc(2)\n                )\n              )(1)\n            )\n          ),\n\n          self(self, size + 1, lambda(opt, choose(opt, _payload, object)))\n        )\n      )\n    )\n  ),\n\n  _list(\n      _list,\n      ,\n      lambda(opt,\n      choose(\n        opt,\n        ,\n\n      )\n    )\n  )(payload)\n)\n","description":"A Church-encoded list of terms. Try LIST(\"@help\") for more.","arguments":{"payload":{"description":"A payload for LIST. Has different properties depending on the type of payload. Refer to the documentation for more.","example":"\"@help\""}}}}}
