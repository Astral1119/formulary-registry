{"name":"flookup","version":"0.1.0","description":"A library of common string comparison algorithms.","owners":["Astral1119"],"dependencies":["error>=0.2.0"],"latest":true,"hasDocs":false,"keywords":"string, levenshtein, jaro, jaro-winkler, flookup","homepage":"https://sheets.wiki","license":"MIT","searchIndex":"flookup A library of common string comparison algorithms. ['string', 'levenshtein', 'jaro', 'jaro-winkler', 'flookup'] FLOOKUP Fuzzy lookup using one of the non-weighted string comparison algorithms. FLOOKUP_THRESHOLD Fuzzy lookup using one of the non-weighted string comparison algorithms. Uses a threshold to return #N/A if there are no good matches. JAROSIM Finds the Jaro Similarity between two strings. JWSIM Finds the Jaro-Winkler Similarity between two strings. LEVDIST Finds the Levenshtein Distance between two strings. LEVDIST_WEIGHTED Finds the Levenshtein Distance between two strings. Allows weighting for deletion, insertion, and substitution. OSA Finds the Optimal String Alignment between two strings. OSA_WEIGHTED Finds the Optimal String Alignment between two strings. Allows weighting for deletion, insertion, and substitution.","functions":{"FLOOKUP":{"definition":"=map(search_key, lambda(source, sortn(result_range,1,,map(lookup_range, lambda(target, algorithm(source, target))),is_ascending)))\n","description":"Fuzzy lookup using one of the non-weighted string comparison algorithms.","arguments":{"algorithm":{"description":"The non-weighted string comparison algorithm to use.","example":"LEVDIST"},"is_ascending":{"description":"Whether or not to sort by weights ascending. Similarity metrics should generally be descending and distance metrics should be ascending.","example":"TRUE"},"search_key":{"description":"The value to search for.","example":"\"Cats\""},"lookup_range":{"description":"The range to consider for the search. This range must be a singular row or column.","example":"A2:A"},"result_range":{"description":"The range to consider for the result. This range's row or column size should be the same as the lookup_range's, depending on how the lookup is done.","example":"B2:B"}}},"FLOOKUP_THRESHOLD":{"definition":"=map(search_key, lambda(source, let(scores, map(lookup_range, lambda(target, algorithm(source, target))), if(max(scores) < threshold, THROW(\"No similar string exists in lookup_range.\"), sortn(result_range,1,,scores,is_ascending)))))\n","description":"Fuzzy lookup using one of the non-weighted string comparison algorithms. Uses a threshold to return #N/A if there are no good matches.","arguments":{"algorithm":{"description":"The non-weighted string comparison algorithm to use.","example":"LEVDIST"},"is_ascending":{"description":"Whether or not to sort by weights ascending. Similarity metrics should generally be descending and distance metrics should be ascending.","example":"TRUE"},"threshold":{"description":"The cutoff for candidate matches.","example":"0.75"},"search_key":{"description":"The value to search for.","example":"\"Cats\""},"lookup_range":{"description":"The range to consider for the search. This range must be a singular row or column.","example":"A2:A"},"result_range":{"description":"The range to consider for the result. This range's row or column size should be the same as the lookup_range's, depending on how the lookup is done.","example":"B2:B"}}},"JAROSIM":{"definition":"=iferror(lambda(h,i,sort(lambda(f,f(f,h,i,1,floor(max(len(h),len(i))/2)-1))(lambda(f,x,y,n,z,if(n>len(x),lambda(g,average(g/len(h),g/len(i),(g-index(reduce({1,0},sequence(len(h)),lambda(a,c,if(--mid(x,c,1),{find(1,y,index(a,1))+1,index(a,2)}+if(mid(h,c,1)=mid(i,find(1,y,index(a,1)),1),0,{0,1}),a))),2)/2)/g))(sum(--mid(x,sequence(len(h)),1))),lambda(a,if(iserr(a),f(f,substitute(x,mid(x,n,1),0,1),y,n+1,z),f(f,substitute(x,mid(x,n,1),1,1),left(y,a-1)&1&mid(y,a+1,9^9),n+1,z)))(find(mid(x,n,1),left(y,n+z),max(1,n-z))))))))(source,target),0)\n","description":"Finds the Jaro Similarity between two strings.","arguments":{"source":{"description":"Source string.","example":"\"cat\""},"target":{"description":"Target string.","example":"\"act\""}}},"JWSIM":{"definition":"=let(jaro,JAROSIM(source,target),pref_ind,{1;2;3;4},p,max(ifna(filter(pref_ind,exact(left(source,pref_ind),left(target,pref_ind))))),l,0.1,jaro+l*p*(1-jaro))\n","description":"Finds the Jaro-Winkler Similarity between two strings.","arguments":{"source":{"description":"Source string.","example":"\"cat\""},"target":{"description":"Target string.","example":"\"act\""}}},"LEVDIST":{"definition":"=LEVDIST_WEIGHTED(source, target, 1, 1, 1)\n","description":"Finds the Levenshtein Distance between two strings.","arguments":{"source":{"description":"Source string.","example":"\"cat\""},"target":{"description":"Target string.","example":"\"act\""}}},"LEVDIST_WEIGHTED":{"definition":"=index(reduce({0,sequence(1,len(target))},sequence(len(source)),lambda(previous,current,scan(#N/A,sequence(1,len(target)+1),lambda(left,n,min(index(previous,n)+delete_cost,ifna(left+insert_cost),iferror(index(previous,n-1)+if(exact(mid(source,current,1),mid(target,n-1,1)),0,substitute_cost))))))),len(target)+1)\n","description":"Finds the Levenshtein Distance between two strings. Allows weighting for deletion, insertion, and substitution.","arguments":{"source":{"description":"Source string.","example":"\"chat\""},"target":{"description":"Target string.","example":"\"act\""},"delete_cost":{"description":"The cost for deletion.","example":"1"},"insert_cost":{"description":"The cost for insertion.","example":"1"},"substitute_cost":{"description":"The cost for substitution.","example":"1"}}},"OSA":{"definition":"=OSA_WEIGHTED(source, target, 1, 1, 1, 1)\n","description":"Finds the Optimal String Alignment between two strings.","arguments":{"source":{"description":"Source string.","example":"\"cat\""},"target":{"description":"Target string.","example":"\"act\""}}},"OSA_WEIGHTED":{"definition":"=index(\n  reduce(\n    {9^9*sequence(1,len(target)+1);0,sequence(1,len(target))},\n    sequence(len(source)),\n    lambda(a,c,\n      {\n        index(a,2,);\n        index(a,2,1)+delete_cost,\n        scan(\n          index(a,2,1)+delete_cost,\n          sequence(1,len(target)),\n          lambda(x,y,\n            min(\n              index(a,2,y+1)+delete_cost,\n              x+insert_cost,\n              index(a,2,y)+if(exact(mid(source,c,1),mid(target,y,1)),0,substitute_cost),\n              if(or(c<2,y<2),9^9,\n                if(and(exact(mid(source,c-1,1),mid(target,y,1)),exact(mid(source,c,1),mid(target,y-1,1))),\n                  index(a,1,y-1)+transpose_cost,\n                  9^9\n                )\n              )\n            )\n          )\n        )\n      }\n    )\n  ),\n  2,\n  len(target)+1\n)\n","description":"Finds the Optimal String Alignment between two strings. Allows weighting for deletion, insertion, and substitution.","arguments":{"source":{"description":"Source string.","example":"\"cat\""},"target":{"description":"Target string.","example":"\"act\""},"delete_cost":{"description":"The cost for deletion.","example":"1"},"insert_cost":{"description":"The cost for insertion.","example":"1"},"substitute_cost":{"description":"The cost for substitution.","example":"1"},"transpose_cost":{"description":"The cost for transposition.","example":"1"}}}}}
